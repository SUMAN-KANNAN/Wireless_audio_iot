c++
#include <ArduinoWebsockets.h>
#include <WiFi.h>
#include <driver/i2s.h> // Include the I2S driver library
#include <ArduinoJson.h> // Include ArduinoJson for parsing messages
#include <esp_sleep.h> // Include for light sleep functions
#include <driver/adc.h> // Include ADC driver for battery reading

// WiFi credentials
const char* ssid = "YourWiFi";
const char* password = "YourPassword";
// WebSocket server address (replace with your server's IP or domain)
const char* websocket_server_address = "yourserver.com";
const uint16_t websocket_server_port = 5000; // Your Flask app port

// Define the room for this specific ESP32
const char* THIS_ROOM_ID = "conferenceRoom"; // <--- **SET THIS FOR EACH ESP32**

// WebSocket client instances for different purposes
WebsocketsClient audioClient;
WebsocketsClient statusClient;
WebsocketsClient batteryClient;

// I2S configuration (keep as is for now)
#define I2S_BCLK_PIN 26   // Replace with your I2S BCLK pin
#define I2S_LRCK_PIN 25   // Replace with your I2S LRCK (WS) pin
#define I2S_DATA_PIN 22   // Replace with your I2S DATA (DOUT) pin
#define I2S_NUM I2S_NUM_0 // I2S port number (usually I2S_NUM_0 or I2S_NUM_1)
#define SAMPLE_RATE 16000 // Audio sample rate (adjust as needed)
#define BITS_PER_SAMPLE I2S_BITS_PER_SAMPLE_16

// Audio buffer (keep as is for now)
const int audio_buffer_size = 1024; // Adjust buffer size as needed
int16_t audio_buffer[audio_buffer_size];

// Battery reading configuration
#define BATTERY_ADC_CHANNEL ADC1_CHANNEL_0 // Replace with your actual ADC channel (e.g., ADC1_CHANNEL_0 for GPIO36)
#define BATTERY_ADC_UNIT ADC_UNIT_1 // Use ADC_UNIT_1 (or ADC_UNIT_2 if needed)

// Dynamic sleep control
unsigned long lastMessageTime = 0;
const unsigned long activityTimeout = 10000; // 10 seconds inactivity to enter sleep

// Function to connect to WiFi (keep as is)
void connectWiFi() {
    Serial.print("Connecting to WiFi...");
    WiFi.begin(ssid, password);
    while (WiFi.status() != WL_CONNECTED) {
        delay(1000);
        Serial.print(".");
    }
    Serial.println(" Connected!");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
}

// Function to initialize I2S (keep as is for now)
void i2s_init() {
    i2s_config_t i2s_config = {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX), // Master, transmit
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = BITS_PER_SAMPLE,
        .channel_format = I2S_CHANNEL_FMT_RIGHT_LEFT, // Stereo
        .communication_format = I2S_COMM_FORMAT_I2S,  // I2S format
        .intr_alloc_flags = 0,                       // Default interrupt priority
        .dma_buf_count = 6,                          // Number of DMA buffers
        .dma_buf_len = 60,                           // Size of each DMA buffer
        .use_apll = false                            // Use XTAL oscillator
    };

    i2s_pin_config_t pin_config = {
        .bck_io_num = I2S_BCLK_PIN,
        .ws_io_num = I2S_LRCK_PIN,
        .data_out_io_num = I2S_DATA_PIN,
        .data_in_io_num = I2S_PIN_NO_CHANGE // Not used in TX mode
    };

    i2s_driver_install(I2S_NUM, &i2s_config, 0, NULL);
    i2s_set_pin(I2S_NUM, &pin_config);
    i2s_set_clk(I2S_NUM, SAMPLE_RATE, BITS_PER_SAMPLE, I2S_CHANNEL_STEREO); // Set sample rate, bits, and channels
}

// Function to play audio data using I2S (keep as is for now)
void playAudio(const uint8_t* data, size_t len) {
    size_t bytes_written;
    // Write the audio data to the I2S peripheral
    i2s_write(I2S_NUM, data, len, &bytes_written, portMAX_DELAY);
}

// Function to read battery voltage (replace with your actual voltage reading logic)
float readBatteryVoltage() {
    // ** Implement your battery voltage reading logic here **
    // This will depend on your hardware (voltage divider, ADC setup, etc.)
    // Remember to configure the ADC appropriately in setup() if needed (e.g., adc1_config_width, adc1_config_channel_atten)

    // Example using analogRead (assuming voltage divider and default ADC setup):
    // int rawADC = analogRead(BATTERY_ADC_CHANNEL);
    // float voltage = (rawADC / 4095.0) * 3.3 * voltage_divider_factor; // Adjust 3.3V and voltage_divider_factor

    // Placeholder for now, replace with your actual reading
    return 3.7; // Example: return a placeholder voltage
}

// Function to convert voltage to percentage (replace with your actual conversion logic)
int voltageToPercentage(float voltage) {
    // ** Implement your voltage to percentage conversion here **
    // This will depend on your battery chemistry (LiPo, Li-ion, etc.) and voltage range
    // Example for a LiPo battery (adjust min/max voltage):
    // float minVoltage = 3.2; // Fully discharged voltage
    // float maxVoltage = 4.2; // Fully charged voltage
    // int percentage = map(voltage, minVoltage, maxVoltage, 0, 100);

    // Ensure percentage is within 0-100 range
    // percentage = constrain(percentage, 0, 100);

    // Placeholder for now, replace with your actual conversion
    return 85; // Example: return a placeholder percentage
}


// Function to handle incoming messages on the Audio WebSocket
void onAudioMessage(WebsocketsMessage msg) {
    Serial.println("Received message on Audio WebSocket");
    lastMessageTime = millis(); // Reset activity timer

    if (msg.isBinary()) {
        Serial.printf("Received binary audio data of size: %zu\n", msg.size());
        playAudio(msg.data(), msg.size());
    } else {
        // Handle text messages on audio channel (e.g., volume commands)
        String text_msg = msg.getData();
        Serial.printf("Received text data on Audio WebSocket: %s\n", text_msg.c_str());

        // Parse JSON message
        StaticJsonDocument<200> doc;
        DeserializationError error = deserializeJson(doc, text_msg);

        if (error) {
            Serial.print("JSON parsing failed on Audio WebSocket: ");
            Serial.println(error.c_str());
            return;
        }

        // Handle volume command
        if (doc.containsKey("type") && String(doc["type"]) == "volume_set" && doc.containsKey("volume")) {
             int volumeLevel = doc["volume"];
             Serial.printf("Received volume command: %d\n", volumeLevel);
             // ** Implement logic to set MAX98357A volume here **
             // This will depend on how you control the DAC (e.g., I2C, control pin)
        }
         // Add other text message handling specific to the audio channel if needed
    }
}

// Function to handle incoming messages on the Status WebSocket
void onStatusMessage(WebsocketsMessage msg) {
    Serial.println("Received message on Status WebSocket");
    String text_msg = msg.getData();
    Serial.printf("Received text data on Status WebSocket: %s\n", text_msg.c_str());
    // You might receive control messages on the status channel in a more complex system
    // For now, we primarily use the status channel to send status.
}

// Function to handle incoming messages on the Battery WebSocket
void onBatteryMessage(WebsocketsMessage msg) {
    Serial.println("Received message on Battery WebSocket");
    String text_msg = msg.getData();
    Serial.printf("Received text data on Battery WebSocket: %s\n", text_msg.c_str());
     // You might receive acknowledgements or control messages on the battery channel
}


// Function to handle WebSocket events for the Audio WebSocket
void onAudioEvents(WebsocketsEvent event, String data) {
    if (event == WebsocketsEvent::Connect) {
        Serial.println("Audio WebSocket connected");
        // Send room identification after connecting to the audio channel
        String roomIdentificationMessage = "{\"type\": \"room_identification\", \"roomId\": \"" + String(THIS_ROOM_ID) + "\"}";
        audioClient.send(roomIdentificationMessage);
        Serial.printf("Sent room identification: %s\n", roomIdentificationMessage.c_str());

        // Also send initial "Active" status on connection to the Status WebSocket
        if (statusClient.isConnected()) {
            String statusMessage = "{\"room\": \"" + String(THIS_ROOM_ID) + "\", \"status\": \"Active\"}";
            statusClient.send(statusMessage);
             Serial.printf("Sent initial status: %s\n", statusMessage.c_str());
        } else {
             Serial.println("Status WebSocket not connected, cannot send initial status.");
        }


    } else if (event == WebsocketsEvent::Disconnect) {
        Serial.println("Audio WebSocket disconnected");
        Serial.println(data);
        // Attempt to reconnect after a delay (consider a non-blocking approach in loop)
        // delay(5000); // Blocking delay
        // audioClient.connect(websocket_server_address, websocket_server_port, "/ws/audio"); // Reconnect
    } else if (event == WebsocketsEvent::Message) {
        // Messages are handled in onAudioMessage function
    } else if (event == WebsocketsEvent::Data) {
        // Data (for binary messages) is handled in onAudioMessage function
    } else if (event == WebsocketsEvent::Error) {
        Serial.println("Audio WebSocket error");
        Serial.println(data);
    }
}

// Function to handle WebSocket events for the Status WebSocket
void onStatusEvents(WebsocketsEvent event, String data) {
    if (event == WebsocketsEvent::Connect) {
        Serial.println("Status WebSocket connected");
         // You might send initial status here as well, or rely on the audio connection handler
         // String statusMessage = "{\"room\": \"" + String(THIS_ROOM_ID) + "\", \"status\": \"Active\"}";
         // statusClient.send(statusMessage);
         // Serial.printf("Sent initial status from status client: %s\n", statusMessage.c_str());
    } else if (event == WebsocketsEvent::Disconnect) {
        Serial.println("Status WebSocket disconnected");
        Serial.println(data);
        // Attempt to reconnect (consider a non-blocking approach in loop)
        // delay(5000); // Blocking delay
        // statusClient.connect(websocket_server_address, websocket_server_port, "/ws/status"); // Reconnect
    } else if (event == WebsocketsEvent::Error) {
        Serial.println("Status WebSocket error");
        Serial.println(data);
    }
}

// Function to handle WebSocket events for the Battery WebSocket
void onBatteryEvents(WebsocketsEvent event, String data) {
    if (event == WebsocketsEvent::Connect) {
        Serial.println("Battery WebSocket connected");
         // You might send initial battery status here if needed
         // The periodic sending is handled in the loop()
    } else if (event == WebsocketsEvent::Disconnect) {
        Serial.println("Battery WebSocket disconnected");
        Serial.println(data);
        // Attempt to reconnect (consider a non-blocking approach in loop)
        // delay(5000); // Blocking delay
        // batteryClient.connect(websocket_server_address, websocket_server_port, "/ws/battery"); // Reconnect
    } else if (event == WebsocketsEvent::Error) {
        Serial.println("Battery WebSocket error");
        Serial.println(data);
    }
}


// Function to enter light sleep
void enterLightSleep() {
    Serial.println("Entering light sleep");
    // Send "Sleep" status before entering sleep
    if (statusClient.isConnected()) {
        String statusMessage = "{\"room\": \"" + String(THIS_ROOM_ID) + "\", \"status\": \"Sleep\"}";
        statusClient.send(statusMessage);
        Serial.printf("Sent sleep status: %s\n", statusMessage.c_str());
    } else {
         Serial.println("Status WebSocket not connected, cannot send sleep status.");
    }

    // Disconnect WebSockets before sleeping (optional but good practice)
    audioClient.close();
    statusClient.close();
    batteryClient.close();

    // You might need to clean up I2S or other peripherals before sleeping
    // i2s_driver_uninstall(I2S_NUM); // Uncomment if needed to save power

    esp_sleep_enable_timer_wakeup(activityTimeout * 1000); // Wake up after activity timeout in microseconds
    esp_light_sleep_start();

    Serial.println("Waking up from light sleep");
    // Reinitialize peripherals and reconnect WebSockets after waking up
    // i2s_init(); // Uncomment if needed
    connectWebSockets(); // Reconnect WebSockets
    lastMessageTime = millis(); // Reset timer after waking up
}

// Function to connect all WebSockets
void connectWebSockets() {
     Serial.println("Connecting WebSockets...");
     audioClient.connect(websocket_server_address, websocket_server_port, "/ws/audio");
     statusClient.connect(websocket_server_address, websocket_server_port, "/ws/status");
     batteryClient.connect(websocket_server_address, websocket_server_port, "/ws/battery");
}


void setup() {
    Serial.begin(115200);
    delay(1000);

    connectWiFi(); // Connect to WiFi

    // Configure ADC for battery reading (adjust attenuation and width as needed)
    adc1_config_width(ADC_WIDTH_BIT_12); // Example: 12-bit resolution
    adc1_config_channel_atten(BATTERY_ADC_CHANNEL, ADC_ATTEN_DB_11); // Example: 11dB attenuation

    i2s_init(); // Initialize I2S for audio playback

    // Set WebSocket event and message handlers for each client
    audioClient.onMessage(onAudioMessage);
    audioClient.onEvent(onAudioEvents);

    statusClient.onMessage(onStatusMessage);
    statusClient.onEvent(onStatusEvents);

    batteryClient.onMessage(onBatteryMessage);
    batteryClient.onEvent(onBatteryEvents);

    // Connect all WebSockets
    connectWebSockets();

    lastMessageTime = millis(); // Initialize activity timer
}

void loop() {
    // Poll each WebSocket client to process messages and events
    audioClient.poll();
    statusClient.poll();
    batteryClient.poll();

    // Check for inactivity to enter sleep mode
    // Ensure audioClient is connected before checking inactivity for sleep
    if (millis() - lastMessageTime > activityTimeout && audioClient.isConnected()) {
        enterLightSleep();
        lastMessageTime = millis(); // Reset timer after waking up
        // Reconnect WebSockets are handled in enterLightSleep/connectWebSockets
    }

    // ** Add Battery Measurement and Sending Logic Here **
    unsigned long currentMillis = millis();
    static unsigned long lastBatterySendTime = 0;
    const unsigned long batterySendInterval = 60000; // Send battery every 60 seconds

    // Send battery status periodically if battery client is connected
    if (currentMillis - lastBatterySendTime >= batterySendInterval && batteryClient.isConnected()) {
         float batteryVoltage = readBatteryVoltage(); // Read actual battery voltage
         int batteryPercentage = voltageToPercentage(batteryVoltage); // Convert to percentage

         // Create the JSON message
         StaticJsonDocument<100> doc; // Adjust size if needed
         doc["room"] = THIS_ROOM_ID;
         doc["percentage"] = batteryPercentage;

         String batteryMessage;
         serializeJson(doc, batteryMessage);

         batteryClient.send(batteryMessage); // Send the JSON message
         Serial.printf("Sent battery status: %s\n", batteryMessage.c_str());

         lastBatterySendTime = currentMillis; // Update the last send time
    }


    // Add other tasks here, but avoid long blocking operations
    // For example, check for button presses, sensor readings, etc.
}
